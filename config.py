import os, sys, ConfigParser, StringIO, socket, urllib2
import utils
import parameters as param

update_available = False
update_version = 0

class dotdict(dict):
    def __getattr__(self, attr):
        return self.get(attr, None)
    __setattr__= dict.__setitem__
    __delattr__= dict.__delitem__


def parse_config(configpath):
    config = None
    if not (param.CLINICAL_MODE and configpath=='config.ini'):
        fullpath=os.path.join(utils.get_data_dir(),configpath)
        if not os.path.isfile(fullpath):
            rewrite_configfile(configpath,overwrite=False)

        # The following is a routine to overwrite older config files with the new one.
        oldconfigfile=open(fullpath,'r+')
        while oldconfigfile:
            line=oldconfigfile.readline()
            if line=='':  # EOF reached. string 'generated by Brain Workshop' not found
                oldconfigfile.close()
                rewrite_configfile(configpath,overwrite=True)
                break
            if line.find('generated by Brain Workshop')>-1:
                splitline=line.split()
                version=splitline[5]
                if version<param.CONFIG_OVERWRITE_IF_OLDER_THAN:
                    oldconfigfile.close()
                    os.rename(fullpath,fullpath+'.'+version+'.bak')
                    rewrite_configfile(configpath,overwrite=True)
                break
        oldconfigfile.close()

        try:
            config=ConfigParser.ConfigParser()
            config.read(os.path.join(utils.get_data_dir(),configpath))
        except:
            if configpath != 'config.ini':
                utils.quit_with_error('Unable to load config file: %s' %
                                 os.path.join(utils.get_data_dir(), configpath))

    defaultconfig=ConfigParser.ConfigParser()
    defaultconfig.readfp(StringIO.StringIO(param.CONFIGFILE_DEFAULT_CONTENTS))

    def try_eval(text):  # this is a one-use function for config parsing
        try:  return eval(text)
        except: return text

    cfg = dotdict()
    if param.CLINICAL_MODE and param.CONFIGFILE=='config.ini': configs=(defaultconfig,)
    else: configs=(defaultconfig,config)
    for config in configs:  # load defaultconfig first, in case of incomplete user's config.ini
        config_items=[(k.upper(),try_eval(v)) for k,v in config.items('DEFAULT')]
        cfg.update(config_items)

    if not 'CHANCE_OF_INTERFERENCE' in cfg:
        cfg.CHANCE_OF_INTERFERENCE=cfg.DEFAULT_CHANCE_OF_INTERFERENCE
    try: cfg.STATSFILE=sys.argv[sys.argv.index('--statsfile')+1]
    except:
        pass
    return cfg

def rewrite_configfile(configfile, overwrite=False):
    global STATS_BINARY
    if param.USER.lower() == 'default':
        statsfile = 'stats.txt'
        STATS_BINARY = 'logfile.dat' # or cmd-line-opts use non-default files
    else:
        statsfile = param.USER + '-stats.txt'
    try:
        os.stat(os.path.join(utils.get_data_dir(), configfile))
    except OSError:
        overwrite = True
    if overwrite:
        f = file(os.path.join(utils.get_data_dir(), configfile), 'w')
        newconfigfile_contents = param.CONFIGFILE_DEFAULT_CONTENTS.replace('stats.txt', statsfile)
        f.write(newconfigfile_contents)
        f.close()
    STATS_BINARY = statsfile.replace('-stats.txt', '-logfile.dat') # let's hope nobody uses '-stats.txt' in their username
    try:
        os.stat(os.path.join(utils.get_data_dir(), statsfile))
    except OSError:
        f = file(os.path.join(utils.get_data_dir(), statsfile), 'w')
        f.close()
    try:
        os.stat(os.path.join(utils.get_data_dir(), STATS_BINARY))
    except OSError:
        f = file(os.path.join(utils.get_data_dir(), STATS_BINARY), 'w')
        f.close()


cfg = parse_config(param.CONFIGFILE)

if param.CLINICAL_MODE:
    cfg.JAEGGI_INTERFACE_DEFAULT_SCORING=False
    cfg.JAEGGI_MODE=True
    cfg.JAEGGI_FORCE_OPTIONS=True
    cfg.JAEGGI_FORCE_OPTIONS_ADDITIONAL=True
    cfg.SKIP_TITLE_SCREEN=True
    cfg.USE_MUSIC=False
elif cfg.JAEGGI_INTERFACE_DEFAULT_SCORING:
    cfg.ANIMATE_SQUARES=False
    cfg.OLD_STYLE_SQUARES=True
    cfg.OLD_STYLE_SHARP_CORNERS=True
    cfg.GRIDLINES=False
    cfg.CROSSHAIRS=True
    cfg.SHOW_FEEDBACK=False
    cfg.BLACK_BACKGROUND=True
    cfg.WINDOW_FULLSCREEN=True
    cfg.HIDE_TEXT=True
    cfg.FIELD_EXPAND=True

if cfg.JAEGGI_MODE and not cfg.JAEGGI_INTERFACE_DEFAULT_SCORING:
    cfg.GAME_MODE=2
    cfg.VARIABLE_NBACK=0
    cfg.JAEGGI_SCORING=True
    if cfg.JAEGGI_FORCE_OPTIONS:
        cfg.AUDIO1_SETS=['letters']
        cfg.ANIMATE_SQUARES=False
        cfg.OLD_STYLE_SQUARES=True
        cfg.OLD_STYLE_SHARP_CORNERS=True
        cfg.GRIDLINES=False
        cfg.CROSSHAIRS=True
        cfg.SHOW_FEEDBACK=False
        cfg.THRESHOLD_FALLBACK_SESSIONS=1
        cfg.NUM_TRIALS_FACTOR=1
        cfg.NUM_TRIALS_EXPONENT=1
    if cfg.JAEGGI_FORCE_OPTIONS_ADDITIONAL:
        cfg.BLACK_BACKGROUND=True
        cfg.WINDOW_FULLSCREEN=True
        cfg.HIDE_TEXT=True
        cfg.FIELD_EXPAND=True

if not cfg.USE_SESSION_FEEDBACK:
    cfg.USE_MUSIC=False
    cfg.USE_APPLAUSE=False

if cfg.BLACK_BACKGROUND:
    cfg.COLOR_TEXT=cfg.COLOR_TEXT_BLK


def get_threshold_advance():
    if cfg.JAEGGI_SCORING:
        return cfg.JAEGGI_ADVANCE
    return cfg.THRESHOLD_ADVANCE


def get_threshold_fallback():
    if cfg.JAEGGI_SCORING:
        return cfg.JAEGGI_FALLBACK
    return cfg.THRESHOLD_FALLBACK


# The colors of the squares in Triple N-Back mode are defined here.
# Color 1 is used in Dual N-Back mode.
def get_color(color):
    if color in (4, 7) and cfg.BLACK_BACKGROUND:
        return cfg['COLOR_%i_BLK' % color]
    return cfg['COLOR_%i' % color]

# this function checks if a new update for Brain Workshop is available.
def update_check():
    global update_available
    global update_version
    socket.setdefaulttimeout(param.TIMEOUT_SILENT)
    req = urllib2.Request(param.WEB_VERSION_CHECK)
    try:
        response = urllib2.urlopen(req)
        version = response.readline().strip()
    except:
        return
    if version > param.VERSION: # simply comparing strings works just fine
        update_available = True
        update_version = version

if cfg.VERSION_CHECK_ON_STARTUP and not param.CLINICAL_MODE:
    update_check()
try:
    # workaround for pyglet.gl.ContextException error on certain video cards.
    os.environ["PYGLET_SHADOW_WINDOW"]="0"
    # import pyglet
    import pyglet
    from pyglet.gl import *
    if param.NOVBO: pyglet.options['graphics_vbo'] = False
    from pyglet.window import key
except:
    utils.quit_with_error('Error: unable to load pyglet.  If you already installed pyglet, \
                            please ensure ctypes is installed.  Please visit %s' % param.WEB_PYGLET_DOWNLOAD)
try:
    pyglet.options['audio'] = ('directsound', 'openal', 'alsa', )
    # use in pyglet 1.2: pyglet.options['audio'] = ('directsound', 'pulse', 'openal', )
    import pyglet.media
except:
    utils.quit_with_error('No suitable audio driver could be loaded.')