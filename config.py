import os, sys, ConfigParser, StringIO
from utils import *
import parameters as param


class dotdict(dict):
    def __getattr__(self, attr):
        return self.get(attr, None)
    __setattr__= dict.__setitem__
    __delattr__= dict.__delitem__


def parse_config(configpath):
    if not (param.CLINICAL_MODE and configpath=='config.ini'):
        fullpath=os.path.join(get_data_dir(),configpath)
        if not os.path.isfile(fullpath):
            rewrite_configfile(configpath,overwrite=False)

        # The following is a routine to overwrite older config files with the new one.
        oldconfigfile=open(fullpath,'r+')
        while oldconfigfile:
            line=oldconfigfile.readline()
            if line=='':  # EOF reached. string 'generated by Brain Workshop' not found
                oldconfigfile.close()
                rewrite_configfile(configpath,overwrite=True)
                break
            if line.find('generated by Brain Workshop')>-1:
                splitline=line.split()
                version=splitline[5]
                if version<param.CONFIG_OVERWRITE_IF_OLDER_THAN:
                    oldconfigfile.close()
                    os.rename(fullpath,fullpath+'.'+version+'.bak')
                    rewrite_configfile(configpath,overwrite=True)
                break
        oldconfigfile.close()

        try:
            config=ConfigParser.ConfigParser()
            config.read(os.path.join(get_data_dir(),configpath))
        except:
            if configpath != 'config.ini':
                quit_with_error(_('Unable to load config file: %s') %
                                 os.path.join(get_data_dir(), configpath))

    defaultconfig=ConfigParser.ConfigParser()
    defaultconfig.readfp(StringIO.StringIO(param.CONFIGFILE_DEFAULT_CONTENTS))

    def try_eval(text):  # this is a one-use function for config parsing
        try:  return eval(text)
        except: return text

    cfg = dotdict()
    if param.CLINICAL_MODE and param.CONFIGFILE=='config.ini': configs=(defaultconfig,)
    else: configs=(defaultconfig,config)
    for config in configs:  # load defaultconfig first, in case of incomplete user's config.ini
        config_items=[(k.upper(),try_eval(v)) for k,v in config.items('DEFAULT')]
        cfg.update(config_items)

    if not 'CHANCE_OF_INTERFERENCE' in cfg:
        cfg.CHANCE_OF_INTERFERENCE=cfg.DEFAULT_CHANCE_OF_INTERFERENCE
    try: cfg.STATSFILE=sys.argv[sys.argv.index('--statsfile')+1]
    except:
        pass
    return cfg

def rewrite_configfile(configfile, overwrite=False):
    global STATS_BINARY
    if param.USER.lower() == 'default':
        statsfile = 'stats.txt'
        STATS_BINARY = 'logfile.dat' # or cmd-line-opts use non-default files
    else:
        statsfile = param.USER + '-stats.txt'
    try:
        os.stat(os.path.join(get_data_dir(), configfile))
    except OSError:
        overwrite = True
    if overwrite:
        f = file(os.path.join(get_data_dir(), configfile), 'w')
        newconfigfile_contents = param.CONFIGFILE_DEFAULT_CONTENTS.replace('stats.txt', statsfile)
        f.write(newconfigfile_contents)
        f.close()
    STATS_BINARY = statsfile.replace('-stats.txt', '-logfile.dat') # let's hope nobody uses '-stats.txt' in their username
    try:
        os.stat(os.path.join(get_data_dir(), statsfile))
    except OSError:
        f = file(os.path.join(get_data_dir(), statsfile), 'w')
        f.close()
    try:
        os.stat(os.path.join(get_data_dir(), STATS_BINARY))
    except OSError:
        f = file(os.path.join(get_data_dir(), STATS_BINARY), 'w')
        f.close()


cfg = parse_config(param.CONFIGFILE)

if param.CLINICAL_MODE:
    cfg.JAEGGI_INTERFACE_DEFAULT_SCORING=False
    cfg.JAEGGI_MODE=True
    cfg.JAEGGI_FORCE_OPTIONS=True
    cfg.JAEGGI_FORCE_OPTIONS_ADDITIONAL=True
    cfg.SKIP_TITLE_SCREEN=True
    cfg.USE_MUSIC=False
elif cfg.JAEGGI_INTERFACE_DEFAULT_SCORING:
    cfg.ANIMATE_SQUARES=False
    cfg.OLD_STYLE_SQUARES=True
    cfg.OLD_STYLE_SHARP_CORNERS=True
    cfg.GRIDLINES=False
    cfg.CROSSHAIRS=True
    cfg.SHOW_FEEDBACK=False
    cfg.BLACK_BACKGROUND=True
    cfg.WINDOW_FULLSCREEN=True
    cfg.HIDE_TEXT=True
    cfg.FIELD_EXPAND=True

if cfg.JAEGGI_MODE and not cfg.JAEGGI_INTERFACE_DEFAULT_SCORING:
    cfg.GAME_MODE=2
    cfg.VARIABLE_NBACK=0
    cfg.JAEGGI_SCORING=True
    if cfg.JAEGGI_FORCE_OPTIONS:
        cfg.AUDIO1_SETS=['letters']
        cfg.ANIMATE_SQUARES=False
        cfg.OLD_STYLE_SQUARES=True
        cfg.OLD_STYLE_SHARP_CORNERS=True
        cfg.GRIDLINES=False
        cfg.CROSSHAIRS=True
        cfg.SHOW_FEEDBACK=False
        cfg.THRESHOLD_FALLBACK_SESSIONS=1
        cfg.NUM_TRIALS_FACTOR=1
        cfg.NUM_TRIALS_EXPONENT=1
    if cfg.JAEGGI_FORCE_OPTIONS_ADDITIONAL:
        cfg.BLACK_BACKGROUND=True
        cfg.WINDOW_FULLSCREEN=True
        cfg.HIDE_TEXT=True
        cfg.FIELD_EXPAND=True

if not cfg.USE_SESSION_FEEDBACK:
    cfg.USE_MUSIC=False
    cfg.USE_APPLAUSE=False

if cfg.BLACK_BACKGROUND:
    cfg.COLOR_TEXT=cfg.COLOR_TEXT_BLK


def get_threshold_advance():
    if cfg.JAEGGI_SCORING:
        return cfg.JAEGGI_ADVANCE
    return cfg.THRESHOLD_ADVANCE


def get_threshold_fallback():
    if cfg.JAEGGI_SCORING:
        return cfg.JAEGGI_FALLBACK
    return cfg.THRESHOLD_FALLBACK